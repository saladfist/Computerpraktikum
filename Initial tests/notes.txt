I think a possible better and maybe faster alternative is to decompose the space into (hyper-)cubes
of length tau put every datapoint into a dictionary which maps the index (position) to its cube(-index). 
We then take a random cube and can enter every contained datapoint to a B cluster and query each of the 3**d-1 
neighbors of the cube into a stack and check the distance between points in there to the first cube. Iteratively when 
this is finished and there were points found in the neighboring cubes search these cubes neighbors. cubes 
already searched during this iteration should be exempt due to redundancy (maybe with list of already searched cubes).
When this method runs out of unsearched cubes, choose a next random point not contained in this B.  




I think the blocky output when the number of datapoints is high is due to the definition of h_D_delta
the density becomes very 


# def get_tau_connected_clusters(M,tau,dimension): #get B sets 
#     visited=set()
#     B=[]
#     M_list = list(M)
#     for start_point in M_list:
#         if start_point in visited:
#             continue #ensures we only start newq clusters from unvisited points
#         current_cluster=set()
#         #stacks
#         stack=[start_point]
#         while stack: #while there are points in the stack, we can explore new paths else breaks
#             point=stack.pop() #removes point from stack, if now point found breaks loop maybe more efficient with an actual stack which can faster delete ends f.e "collections.deque"
#             if point in visited:
#                 continue
#             visited.add(point)
#             current_cluster.add(point)
#             #find neighbors with distance leq tau
#             for other_point in M_list:
#                 if other_point not in visited:
#                     #dist=||point-other_point|| maybe more efficient caluclation possivble
#                     dist_2=0
#                     for d in range(dimension):
#                         dist_2+=(get_coordinate(data,point,d)-get_coordinate(data,other_point,d))**2
#                     dist=dist_2**.5
#                     if dist<=tau:
#                         stack.append(other_point)
#         B.append(current_cluster)
#     return B

# def build_tau_graph(data,tau,dimension):
#     #build graph with eges (i,j) if |xi - xj| <= tau
    
#     tau_sq=tau**2

#     cube_idx_to_point=defaultdict(list)
#     # point_to_cube_index = {}
    
#     def get_cube_idx(point):
#         #finds the cube a particular point belongs to 
#         return tuple([int((get_coordinate(data,point,d)+1)/(2*tau)) for d in range(dimension)])
    
#     def get_cube_neighbors(dimension):
#         #returns a list of lists with every distance a cube has to its neighbors in d dimensions
#         offsets=[[]]
#         for d in range(dimension):
#             offsets=[o+[i] for o in offsets for i in [-1,0,1]]
#         return [tuple(o) for o in offsets]
#     for i in range(len(data)):
#         c_idx=get_cube_idx(i)
#         cube_idx_to_point[c_idx].append(i) #defaultdict means that if key (c_idx) doesnt exist we create it with corresponding empty list to which we append our values
#         # point_to_cube_index[i]=c_idx
#     offsets=get_cube_neighbors(dimension)
#     adj=[[] for i in range(len(data))] #adjacency graph initialized empty
    
#     for c_idx,points in cube_idx_to_point.items():
#         for offset in offsets:
#             nc=tuple(c_idx[d]+offset[d] for d in range(dimension))
#             if nc not in cube_idx_to_point:
#                 continue
#             for p in points:
#                 px=data[p]
#                 for q in cube_idx_to_point[nc]:
#                     if q<p: #we walk the array from left to right so if q<p we have already encountered this potential edge
#                         continue 
#                     qx=data[q]
#                     dist_sq=0.0
#                     for d in range(dimension):
#                         dist_sq+=(px[d]-qx[d])**2
#                         if dist_sq>tau_sq:
#                             break
#                         if dist_sq<=tau_sq:
#                             adj[p].append(q)
#                             adj[q].append(p)
#     return adj
